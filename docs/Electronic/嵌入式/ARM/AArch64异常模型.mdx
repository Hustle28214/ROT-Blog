
import WordCount from '../../../../src/components/WordCount/WordCount.jsx';
import Mermaid from '@theme/Mermaid';

<WordCount>

出于安全考虑，现代处理器架构往往存在权限的概念。比如说我们不希望用户能够直接修改内核代码以免造成内核崩溃，又需要给予用户一定的配置内核功能的能力。此时我们需要权限，赋予用户特权，以实现功能隔离。

## 1. 权限、异常级别

### 1.1 异常级别

AArch64 中权限的名称为异常级别,通常缩写为 EL。

异常级别为编号,通常缩写为 EL\<x\>,其中 \<x\> 为介于 0 到 3 之间的数字。权限级别越高,数字越高。例如,最低级别的权限称为EL0。 

通常来说，EL对应的级别随着系统抽象层级的提升而降低。

<Mermaid
value={`quadrantChart
    title ARM Privilege Levels Hierarchy
    x-axis "Low Privilege" --> "High Privilege"
    y-axis "User Space" --> "System Space"
    quadrant-1 "Application Space"
    quadrant-2 "Kernel Space"
    quadrant-3 "Virtualization"
    quadrant-4 "Secure Firmware"
    
    "EL0: Application": [0.2, 0.2]
    "EL1: Rich OS": [0.6, 0.4]
    "EL2: Hypervisor": [0.8, 0.6]
    "EL3: Secure Monitor": [0.95, 0.8]`}
/>

异常级别只能在特定的事件发生时改变。


1. 发生异常（Taking an exception）
2. 从异常返回（Returning from an exception）
3. 处理器复位（Processor reset）
4. 在调试状态期间（During Debug state）
5. 退出调试状态（Exiting from Debug state）

## 1.2 特权类型

AArch64 Exception 模型有两种类型的权限:

1. 内存系统中的权限
2. 从访问处理器资源的角度来看是特权

两种类型的权限都受当前特权异常级别的影响。

如下图是AArch64特权类型图：

<Mermaid
value={`graph TD
    A[AArch64特权类型] --> B[内存系统特权<br>Memory Privilege]
    A --> C[处理器资源访问特权<br>Processor Resource Access]
    
    B --> B1[通过MMU管理内存访问权限]
    C --> C1[通过系统寄存器控制访问]
    
    B1 --> B2[EL0: 非特权访问权限]
    B1 --> B3["EL1/2/3: 特权访问权限"]
    
    C1 --> C2[寄存器名后缀指示<br>最低访问EL]
    
    style A fill:#e3f2fd,stroke:#1565c0,stroke-width:3px`}
/>

异常类型处理的寄存器：

<Mermaid
value={`quadrantChart
    title 异常处理关键寄存器功能分类
    x-axis "状态保存" --> "异常控制"
    y-axis "异常原因" --> "异常地址"
    quadrant-1 "异常返回地址"
    quadrant-2 "异常控制配置"
    quadrant-3 "异常原因信息"
    quadrant-4 "异常地址信息"
    
    "ELR_ELx": [0.8, 0.3]
    "SPSR_ELx": [0.7, 0.4]
    "VBAR_ELx": [0.9, 0.6]
    "SCTLR_ELx": [0.85, 0.7]
    "HCR_EL2": [0.9, 0.8]
    "SCR_EL3": [0.95, 0.85]
    "ESR_ELx": [0.3, 0.7]
    "FAR_ELx": [0.2, 0.8]`}/>

处理异常的关键寄存器说明：


| 寄存器 | 实际可用级别 | 说明 |
|--------|--------------|------|
| `ELR_ELx` | EL1, EL2, EL3 | 异常链接寄存器，每个级别独立 |
| `ESR_ELx` | EL1, EL2, EL3 | 异常综合征寄存器，每个级别独立 |
| `FAR_ELx` | EL1, EL2, EL3 | 故障地址寄存器，每个级别独立 |
| `HCR_ELx` | EL2 | 仅EL2可用，控制虚拟化 |
| `SCR_ELx` | EL3 | 仅EL3可用，控制安全状态 |
| `SCTLR_ELx` | EL1, EL2, EL3 | 系统控制寄存器，每个级别独立 |
| `SPSR_ELx` | EL1, EL2, EL3 | 保存程序状态寄存器，每个级别独立 |
| `VBAR_ELx` | EL1, EL2, EL3 | 向量基地址寄存器，每个级别独立 |

## 2. 执行与安全状态 

Armv8-A 或 Armv9-A 处理器的当前状态由异常级别和当前执行状态决定。

当前执行状态定义了通用寄存器的标准宽度和可用的指令集。

Armv8-A 和 Armv9-A 支持两个执行语句（说明图可见于指令集那一章节）:

1. AArch32 是一个 32 位执行状态。在此状态下的操作与先前的架构具有向后兼容。它支持 T32 和 A32 指令集。标准寄存器宽度为32位。 
2. AArch64 是一个 64 位执行状态。它支持A64指令集。标准寄存器宽度为64位。 

## 2.1 更改执行状态

执行状态切换规则如下：

<Mermaid 
value={`graph TD
    A[执行状态切换时机] --> B[复位时 Reset]
    A --> C[异常级别变化时<br>Exception Level Change]
    
    C --> D[低EL到高EL<br>Lower → Higher]
    C --> E[高EL到低EL<br>Higher → Lower]
    
    D --> F["保持原状态 或 切换到 AArch64"]
    E --> G["保持原状态 或 切换到 AArch32"]
    
    F --> H[64位层可托管32位层]
    G --> I[32位层不能托管64位层]
    
    style A fill:#e3f2fd,stroke:#1565c0
    style H fill:#bbdefb,stroke:#0d47a1
    style I fill:#ffcdd2,stroke:#c62828`}
/>

## 2.2 安全状态

安全状态是TrustZone技术的一部分，用于将系统划分为安全世界（Secure world）和非安全世界（Non-secure world，也称为正常世界）。在ARMv9-A中，还引入了领域管理扩展（RME），增加了两个新的安全状态：领域状态（Realm state）和根状态（Root state）。

安全状态决定了处理单元（PE）可以访问哪些物理地址空间和系统寄存器。安全状态的变化必须经过EL3（最高异常级别）的控制。

<Mermaid
value={`graph TD
    A[ARM安全状态] --> B["传统TrustZone模型<br>（Armv8-A）"]
    A --> C["增强TrustZone模型<br>（Armv9-A + RME）"]
    
    B --> B1[非安全状态 Non-Secure<br>也称为Normal World]
    B --> B2[安全状态 Secure<br>也称为Secure World]
    
    C --> C1[非安全状态]
    C --> C2[安全状态]
    C --> C3[领域状态 Realm]
    C --> C4[根状态 Root ,EL3专属]
    
    style B1 fill:#bbdefb,stroke:#1565c0
    style B2 fill:#c8e6c9,stroke:#2e7d32
    style C3 fill:#fff3e0,stroke:#f57c00
    style C4 fill:#ffcdd2,stroke:#c62828`}
/>

## 2.3 



</WordCount>