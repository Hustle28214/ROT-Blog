import WordCount from '../../../../src/components/WordCount/WordCount';

<WordCount>



## 1. 基本概念

HIP编程方法是在类GPU加速器DCU上运行高性能的并行计算。DCU加速卡上使用的编程模型为AMD公司开发的ROCm 编程模型。HIP编程模型是ROCm编程模型的一个扩展，它允许开发人员使用C/C++语言编写代码，并使用HIP库来调用ROCm库。

它是一种显式并行编程模型，和CUDA编程是类似的（就像它们都有核函数）。

> 文档：https://rocm.docs.amd.com/projects/HIP/en/docs-6.0.0/developer_guide/build.html


在CPU上运行的部分称为主机端（host），在DCU加速器上云霄的部分称为设备端（device）。主机端代码是CPU代码，代码在CPU上运行，入口函数是main。而设备端就是指加速器设备，代码对应在加速器上运行。代码采用扩展的C语法（HIP_C），设备端代码组织成核函数运行。

HIP使用Runtime API来在主机端分配设备显存，管理主机端和设备端的内存拷贝，运行设备端核函数等。

设备端代码由HIP_C构成并运行在DCU加速器上，被称为核函数(Kernel)。

## 2. HIP异构程序实现流程（CPU+DCU）

1. 将需要在设备端进行运算的数据从主机端内存传输至设备内存。（hipMalloc）

2. 启动核函数对已传输至DCU上的数据进行运算等操作。

3. 将运算结果从设备端传输回主机端内存。

## 3. HIP模型线程组织模式

HIP异构编程核函数执行模型由thread-block-grid三层结构组成。

线程是并行程序的基本构执行单元，每个核函数所启动的线程都有一个唯一的线程ID，通过HIP内置的hipthreadldx进行访问。这个变量是一个三分量矢量，在x,y,z方向上分别命名为hipthreadldx_x,hipthreadldx_y,hipthreadldx_z。

对于block与grid拥有同样的内置变量，从而确定线程在全局中的偏移量（线程局部存储（Thread Local Storage, TLS）中的数据在进程的全局内存空间中的位置偏移）。

## 常用卷积算法

常用卷积算法有4种：

### 直接卷积计算

卷积计算公式：

$$
y(i,j)= \sum_{m=-(M-1)/2}^{M/2} \sum_{n=-(N-1)/2}^{N/2} x(i+m,j+n) \cdot h(m,n)
$$

按照卷积的计算特性直接进行计算。

卷积核中的权重矩阵在经过处理（补边）后的输入图像中滑动，每次在输入图像中会覆盖一个与权重矩阵大小一致的子矩阵与之进行对应元素的相乘并累加（点积运算）。

### Winograd算法

通过特定的计算公式增加加法计算来减少乘法的计算次数达到优化目的。

Winograd算法的实现过程如下：
1. 分解卷积运算：将卷积运算分解成多个较小的矩阵乘法和加法运算，从而减少实际的乘法次数。通常情况下，卷积运算涉及多个乘法和加法操作，通过算法分解后，可以减少这些操作的数量。

2. 应用Winograd变换：通过应用Winograd变换，将输入数据和卷积核转换为一个新的域。这个新的域使得卷积运算转化为更少的乘法操作。例如，Winograd F(2, 3, 3)算法将2x3x3的卷积核转化为一组较小的矩阵，从而减少计算量。

3. 执行变换和卷积：在变换后的域中进行卷积运算。由于在新域中卷积计算的乘法次数较少，这一步骤的计算复杂度会有所降低。

4. 逆变换：将卷积结果从变换后的域映射回原始数据域。此步骤将变换后的卷积结果恢复到原始数据空间中，得到最终的卷积结果。

5. 后处理：对逆变换后的结果进行必要的后处理步骤，以适应实际应用中的需求，例如调整边界效应或去除填充等。

```cpp
#include <iostream>
#include <vector>
#include <cmath>

using namespace std;

// Matrix multiplication helper function
vector<vector<float>> matMult(const vector<vector<float>>& A, const vector<vector<float>>& B) {
    int rowsA = A.size();
    int colsA = A[0].size();
    int colsB = B[0].size();
    
    vector<vector<float>> C(rowsA, vector<float>(colsB, 0));
    
    for (int i = 0; i < rowsA; ++i) {
        for (int j = 0; j < colsB; ++j) {
            for (int k = 0; k < colsA; ++k) {
                C[i][j] += A[i][k] * B[k][j];
            }
        }
    }
    
    return C;
}

// Winograd F(2, 3, 3) convolution implementation
vector<vector<float>> winogradF23Convolution(const vector<vector<float>>& input, const vector<vector<float>>& kernel) {
    // Define the Winograd transformation matrices
    vector<vector<float>> G = {{1, 0, 0},
                               {0, 1, 0},
                               {0, 0, 1}};
                               
    vector<vector<float>> B = {{1, 1, 0},
                               {1, -1, 0},
                               {0, 0, 1}};
                               
    vector<vector<float>> B_inv = {{0.5, 0.5, 0},
                                   {0.5, -0.5, 0},
                                   {0, 0, 1}};
                               
    // Apply Winograd transformations
    vector<vector<float>> A = matMult(B, input);
    vector<vector<float>> K = matMult(B, kernel);
    
    // Perform convolution in the transformed domain
    vector<vector<float>> C = matMult(A, K);
    
    // Apply inverse Winograd transformations
    vector<vector<float>> output = matMult(C, B_inv);
    
    return output;
}

int main() {
    // Example input and kernel
    vector<vector<float>> input = {{1, 2, 3},
                                   {4, 5, 6},
                                   {7, 8, 9}};
                                   
    vector<vector<float>> kernel = {{1, 0, -1},
                                    {0, 1, 0},
                                    {1, 0, 1}};
    
    // Perform Winograd convolution
    vector<vector<float>> result = winogradF23Convolution(input, kernel);
    
    // Print result
    cout << "Result of Winograd F(2, 3, 3) convolution:" << endl;
    for (const auto& row : result) {
        for (float val : row) {
            cout << val << " ";
        }
        cout << endl;
    }
    
    return 0;
}
```

### FFT算法（快速傅里叶变换）

将输入图像和卷积核进行FFT变换，在频域中进行卷积，再进行IFFT变换，得到空域卷积结果。

并行快速傅里叶变换是斯坦福CS315b的一个课设题目。



</WordCount>