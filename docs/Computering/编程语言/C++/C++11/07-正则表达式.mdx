import WordCount from '../../../../../src/components/WordCount/WordCount';
import Mermaid from '@theme/Mermaid';

<WordCount>

正则表达式用于字符串的模式匹配、搜索和替换。它基于 ECMAScript 正则表达式语法，并允许选择其他语法（如 basic、extended、awk、grep、egrep）。

要使用正则表达式，你需要引入`<regex>`头文件。

## 1. 核心组件

| 组件 | 说明 |
|------|------|
| `std::regex` / `std::wregex` | 表示一个正则表达式对象，分别用于 char 和 wchar_t 字符。 |
| `std::match_results` | 保存一次匹配操作的结果，其特化版本有 `std::cmatch`（const char*）、`std::smatch`（std::string）、`std::wcmatch`（const wchar_t*）、`std::wsmatch`（std::wstring）。 |
| `std::regex_match` | 判断整个字符序列是否完全匹配正则表达式。 |
| `std::regex_search` | 在字符序列中搜索第一个匹配的子串。 |
| `std::regex_replace` | 将匹配的子串替换为指定的格式字符串。 |
| `std::regex_iterator` | 迭代遍历所有匹配的子串。 |
| `std::regex_token_iterator` | 迭代遍历匹配结果中的指定子表达式或未匹配的部分。 |
| `std::regex_error` | 正则表达式编译或使用过程中抛出的异常类型。 |


## 2. 正则表达式语法选项

| 标志 | 说明 |
|------|------|
| `std::regex::ECMAScript` | 默认语法，遵循 ECMAScript 正则表达式规范（最常用，功能最全）。 |
| `std::regex::basic` | 基础 POSIX 正则表达式语法。 |
| `std::regex::extended` | 扩展 POSIX 正则表达式语法。 |
| `std::regex::awk` | awk 工具使用的语法。 |
| `std::regex::grep` | grep 工具使用的语法。 |
| `std::regex::egrep` | egrep 工具使用的语法（等于 extended）。 |
| `std::regex::icase` | 匹配时不区分大小写。 |
| `std::regex::nosubs` | 不存储子表达式匹配结果，提高性能。 |
| `std::regex::optimize` | 指示编译器构建更快的正则表达式（可能增加编译时间）。 |
| `std::regex::collate` | 考虑本地化语言环境的字符对照规则。 |


:::tip
- **语法选择**：通常使用默认的 `ECMAScript` 语法即可满足绝大多数需求，它支持现代正则表达式特性（如 `\d`、`\w`、非捕获组 `(?:...)`、前瞻 `(?=...)` 等）。如果需要兼容 POSIX 风格的工具，可以选用对应的标志。
- **标志组合**：多个标志可以通过按位或（`|`）组合使用，例如 `std::regex::ECMAScript | std::regex::icase` 表示使用 ECMAScript 语法且不区分大小写。
- **性能优化**：
  - `std::regex::optimize` 建议在正则表达式会被重复使用多次（例如在循环中）时启用，它会花费更多编译时间生成更快的匹配状态机。
  - `std::regex::nosubs` 可以禁用捕获组的存储，在不需要提取子表达式时使用可减少内存占用并提高匹配速度。
- **字符类型匹配**：处理宽字符（如 UTF-16）时，应使用 `std::wregex` 和对应的结果类型（`std::wsmatch`、`std::wcmatch`），避免窄字符与宽字符混用。
- **异常处理**：正则表达式编译失败时会抛出 `std::regex_error` 异常，建议在构造 `std::regex` 对象时捕获并处理该异常，以便定位语法错误。
:::

## 3. 基本的几个使用案例

### 验证邮箱格式

```cpp
#include <regex>
#include <iostream>

bool isValidEmail(const std::string& email) {
    std::regex pattern(R"(^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$)");
    return std::regex_match(email, pattern);
}
```

### 提取字符串中的所有数字

```cpp
#include <regex>
#include <string>
#include <vector>

std::vector<int> extractNumbers(const std::string& text) {
    std::regex pattern(R"(\d+)");
    std::sregex_iterator begin(text.begin(), text.end(), pattern);
    std::sregex_iterator end;
    std::vector<int> result;
    for (auto it = begin; it != end; ++it) {
        result.push_back(std::stoi(it->str()));
    }
    return result;
}
```


### 替换敏感词

```cpp
#include <regex>
#include <iostream>

std::string censor(const std::string& text) {
    std::regex pattern("笨蛋");
    return std::regex_replace(text, pattern, "***");
}
```

### 检查密码强度

```cpp
bool isStrongPassword(const std::string& pwd) {
    std::regex pattern(R"(^(?=.*[a-z])(?=.*[A-Z])(?=.*\d).{8,}$)");
    return std::regex_match(pwd, pattern);
}
```

### 分割字符串

```cpp
#include <regex>
#include <vector>

std::vector<std::string> split(const std::string& str) {
    std::regex pattern(R"([ ,]+)");
    std::sregex_token_iterator begin(str.begin(), str.end(), pattern, -1);
    std::sregex_token_iterator end;
    return {begin, end};
}
```

### 匹配 URL

```cpp
std::vector<std::string> findURLs(const std::string& text) {
    std::regex pattern(R"(https?://[^\s]+)");
    std::sregex_iterator begin(text.begin(), text.end(), pattern);
    std::sregex_iterator end;
    std::vector<std::string> urls;
    for (auto it = begin; it != end; ++it) {
        urls.push_back(it->str());
    }
    return urls;
}
```

</WordCount>