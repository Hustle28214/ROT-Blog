import WordCount from '../../../../src/components/WordCount/WordCount';
import Mermaid from '@theme/Mermaid';

<WordCount>

## 深拷贝（Deep Copy）

如果说浅拷贝是只记住了别人的名字和地址，那深拷贝就是连带名字地址把别人的近期动作全部记了个遍。

深拷贝是对象复制的一种方式，它不仅仅复制对象本身的值，还会递归地复制对象所拥有的动态资源（如堆上分配的内存、文件句柄、网络连接等），使得原对象和副本各自拥有独立的资源副本。这样，两个对象在修改或销毁时不会相互影响。

## 为什么需要深拷贝？

在 C++ 等语言中，如果一个类包含指向动态分配内存的指针，默认的拷贝（浅拷贝）只会复制指针的值，导致多个对象的指针指向同一块内存。这会产生严重问题：

1. 重复释放：两个对象析构时都会释放同一块内存，导致程序崩溃。

<details>

<summary>示例</summary>

两个对象通过浅拷贝共享同一块动态内存，当它们相继析构时，会重复释放同一块内存，导致程序崩溃。

```cpp
#include <cstring>
#include <iostream>

class String {
public:
    char* data;

    String(const char* str) {
        data = new char[strlen(str) + 1];
        strcpy(data, str);
        std::cout << "构造函数: " << (void*)data << std::endl;
    }

    // 没有定义拷贝构造函数，编译器生成默认的（浅拷贝）
    ~String() {
        std::cout << "析构函数释放: " << (void*)data << std::endl;
        delete[] data;  // 释放内存
    }
};

int main() {
    String s1("Hello");
    String s2 = s1;          // 浅拷贝：s2.data 指向与 s1.data 相同的内存
    std::cout << "s1.data = " << (void*)s1.data << std::endl;
    std::cout << "s2.data = " << (void*)s2.data << std::endl;
    // 程序结束时，s2 先析构，释放内存；s1 后析构，再次释放同一内存 → 崩溃
    return 0;
}
```
执行结果：
```bash
构造函数: 0x9b3e70
s1.data = 0x9b3e70
s2.data = 0x9b3e70
析构函数释放: 0x9b3e70
析构函数释放: 0x9b3e70

free(): double free detected in tcache 2
run: line 1:     3 Aborted                 (core dumped) LD_LIBRARY_PATH=/usr/local/gcc-9.2.0/lib64 ./a.out

Exited with error status 134
```
</details>

2. 数据共享：修改一个对象的数据会意外地影响另一个对象。

<details>

<summary>示例</summary>

浅拷贝使得两个对象共享同一份数据，修改一个对象的数据会意外地影响另一个对象。

```cpp
#include <iostream>
#include <cstring>

class Buffer {
public:
    int* data;
    size_t size;

    Buffer(size_t sz) : size(sz) {
        data = new int[size];
        for (size_t i = 0; i < size; ++i) data[i] = 0;
    }

    // 默认拷贝构造函数（浅拷贝）
    void set(size_t index, int value) {
        if (index < size) data[index] = value;
    }

    void print() const {
        for (size_t i = 0; i < size; ++i) std::cout << data[i] << ' ';
        std::cout << std::endl;
    }

    ~Buffer() {
        delete[] data;
    }
};

int main() {
    Buffer b1(3);
    b1.set(0, 10);
    b1.set(1, 20);
    b1.set(2, 30);

    Buffer b2 = b1;           // 浅拷贝，b2.data 和 b1.data 指向同一数组

    std::cout << "b1: ";
    b1.print();               // 10 20 30
    std::cout << "b2: ";
    b2.print();               // 10 20 30

    b2.set(1, 99);            // 修改 b2
    std::cout << "修改 b2[1] 为 99 后：" << std::endl;
    std::cout << "b1: ";
    b1.print();               // 10 99 30  ← b1 也被意外修改！
    std::cout << "b2: ";
    b2.print();               // 10 99 30

    return 0;
}
```
执行结果：
```bash
b1: 10 20 30 
b2: 10 20 30 
修改 b2[1] 为 99 后：
b1: 10 99 30 
b2: 10 99 30 

free(): double free detected in tcache 2
run: line 1:     3 Aborted                 (core dumped) LD_LIBRARY_PATH=/usr/local/gcc-9.2.0/lib64 ./a.out

Exited with error status 134
```
</details>


3. 悬垂指针：一个对象释放内存后，另一个对象的指针变成悬垂指针。

<details>

<summary>示例</summary>

浅拷贝使得两个对象共享同一份数据，修改一个对象的数据会意外地影响另一个对象。

```cpp
#include <iostream>
#include <cstring>

class Resource {
public:
    int* data;

    Resource(int value) {
        data = new int(value);
        std::cout << "构造，data = " << (void*)data << ", 值 = " << *data << std::endl;
    }

    // 默认拷贝构造函数（浅拷贝）
    ~Resource() {
        std::cout << "析构，释放 data = " << (void*)data << std::endl;
        delete data;
    }

    int get() const { return *data; }
};

void dangerousFunction(Resource obj) {  // 传参时发生浅拷贝
    std::cout << "在函数内，obj.data = " << (void*)obj.data << ", 值 = " << obj.get() << std::endl;
    // 函数结束时 obj 析构，释放内存
}

int main() {
    Resource r1(42);
    dangerousFunction(r1);      // 传入 r1 的浅拷贝副本，函数内释放内存

    // 此时 r1.data 已成为悬垂指针
    std::cout << "返回 main 后，尝试访问 r1：" << std::endl;
    std::cout << "r1.data = " << (void*)r1.data << std::endl;
    std::cout << "r1 的值 = " << r1.get() << std::endl;  // 未定义行为，可能崩溃或输出随机值

    return 0;
}
```
执行结果：
```bash
构造，data = 0x1cb7e70, 值 = 42
在函数内，obj.data = 0x1cb7e70, 值 = 42
析构，释放 data = 0x1cb7e70
返回 main 后，尝试访问 r1：
r1.data = 0x1cb7e70
r1 的值 = 0
析构，释放 data = 0x1cb7e70

free(): double free detected in tcache 2
run: line 1:     3 Aborted                 (core dumped) LD_LIBRARY_PATH=/usr/local/gcc-9.2.0/lib64 ./a.out

Exited with error status 134
```
</details>


深拷贝通过为每个对象分配独立的内存并复制实际内容，避免了这些问题。


## 实现深拷贝

为了正确复制资源，需要显式定义拷贝构造函数和拷贝赋值运算符：

```cpp

class String {
public:
    char* data;
    
    String(const char* str) {
        data = new char[strlen(str) + 1];
        strcpy(data, str);
    }
    
    // 拷贝构造函数（深拷贝）
    String(const String& other) {
        data = new char[strlen(other.data) + 1];
        strcpy(data, other.data);
    }
    
    // 拷贝赋值运算符（深拷贝）
    String& operator=(const String& other) {
        if (this != &other) {           // 防止自赋值
            delete[] data;               // 释放原有资源
            data = new char[strlen(other.data) + 1];
            strcpy(data, other.data);
        }
        return *this;
    }
    
    ~String() {
        delete[] data;
    }
};
```

## 深拷贝的适用场景

- 类管理动态内存（如 std::vector、std::string 的内部实现）

- 类包含文件指针、数据库连接等资源

- 或需要独立副本的任何情况

## 现代 C++ 的简化

在 C++11 及以后，可以使用智能指针（如 std::shared_ptr）自动管理资源，但智能指针本身是浅拷贝（引用计数共享）。如果确实需要深拷贝，可以：

- 自定义拷贝逻辑（如上例）

- 使用 std::unique_ptr 配合深拷贝（需要手动实现）

- 考虑使用值语义的容器，如 std::vector 已经实现了深拷贝

```cpp
class Widget {
    std::vector<int> data;  // vector 自身是深拷贝的
public:
    Widget(const std::vector<int>& v) : data(v) {}
    // 默认的拷贝构造函数和赋值运算符会调用 vector 的深拷贝，自动处理
};
```
</WordCount>