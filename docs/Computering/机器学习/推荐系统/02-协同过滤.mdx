
import WordCount from '../../../../src/components/WordCount/WordCount.jsx';
import Mermaid from '@theme/Mermaid';

<WordCount>

## 2.1 简介

协同过滤（Collaborative Filtering）是推荐系统中最基础的技术之一。它的基本想法很简单：如果两个用户过去喜欢相似的物品，那么他们未来也可能有相似的偏好。或者反过来说，如果两个物品被相似的用户群体喜欢，那么喜欢其中一个物品的用户也可能喜欢另一个。

协同过滤主要分为两大类：基于用户的协同过滤（User-Based Collaborative Filtering）和基于物品的协同过滤（Item-Based Collaborative Filtering）。无论是哪种方法，核心思想都是利用用户与物品之间的交互数据来进行推荐。

这是两种传统方法，复杂一些的有矩阵分解这种基于模型的方法，通过学习用户和物品的低维向量表示来进行推荐。

## 2.2 基于用户的协同过滤

具有相似历史行为的用户，未来偏好也相似。

UserCF是最早提出的协同过滤方法。它的工作原理很直观：先找到与目标用户购买偏好相似的“邻居用户”，然后基于这些邻居对商品的选择来预测目标用户的偏好。

### 2.2.1 相似度计算

首先我们两两配对用户的时候，需要衡量他们的“相似”程度，常用的方法有杰卡德相似度、余弦相似度、皮尔逊相关系数等。

杰卡德相似度：
$$
\text{Jaccard Similarity}(A, B) = \frac{|A \cap B|}{|A \cup B|}
$$

余弦相似度：

$$
\text{Cosine Similarity}(A, B) = \frac{|A \cap B|}{\sqrt{||A|| \cdot ||B||}}
$$

皮尔逊相关系数：

$$
\text{Pearson Correlation}(A, B) = \frac{\sum (A_i - \bar{A})(B_i - \bar{B})}{\sqrt{\sum (A_i - \bar{A})^2} \sqrt{\sum (B_i - \bar{B})^2}}
$$

### 2.2.2 候选物品推荐

那有了相似度指标之后，我们需要为目标用户推荐物品，预测目标用户对未评分物品的兴趣度。

**简单加权平均：**最直接的方法是用相似度作为权重，对邻居的评分进行加权平均：

$$
\hat{r}_{u,i} = \frac{\sum_{v \in N(u)} \text{sim}(u, v) \cdot r_{v,i}}{\sum_{v \in N(u)} |\text{sim}(u, v)|}
$$

这里，$\hat{r}_{u,i}$是用户$u$对物品$i$的预测评分，$N(u)$是与用户$u$相似的邻居用户集合，$\text{sim}(u, v)$是用户$u$和$v$之间的相似度，$r_{v,i}$是用户$v$对物品$i$的实际评分。

**考虑评分偏置的版本**：为了进一步消除个人评分习惯的影响，我们可以加入偏置修正：

$$
\hat{r}_{u,i} = \bar{r}_u + \frac{\sum_{v \in N(u)} \text{sim}(u, v) \cdot (r_{v,i} - \bar{r}_v)}{\sum_{v \in N(u)} |\text{sim}(u, v)|}
$$

这里，$\bar{r}_u$和$\bar{r}_v$分别是用户$u$和$v$的平均评分。先看邻居们对这个物品的评分相比他们平均水平如何，然后根据目标用户的平均评分水平进行调整。

### 2.2.3 算法优化策略

基于物品倒排表的优化：





</WordCount>