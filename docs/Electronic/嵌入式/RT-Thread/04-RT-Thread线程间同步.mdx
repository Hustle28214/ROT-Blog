import WordCount from '../../../../src/components/WordCount/WordCount.jsx';

<WordCount>


两个线程间的数据传递：

![](https://github.com/user-attachments/assets/2e588072-e5e2-4666-ae45-1fd511a50e9c)

如何使得这两个线程默契配合？如果两个线程都需要访问共享内存，我们甚至会遇到数据一致性的问题。

首先，我们要保证，这两个线程访问的动作必须**互斥进行**，同一时间只应该有一个线程访问共享内存。

我们称两个线程需要访问的同一块代码区称为**临界区**。

:::danger
牢记一个设计原则：在访问临界区的时候只允许一个 (或一类) 线程运行。
:::

在进行线程同步的时候我们需要设计一个优雅的同步机制。为此，引入信号量（semaphore）、互斥量（mutex）、和事件集（event）三大概念。

## 信号量

举个简单的例子理解信号量：去餐馆等位，服务员叫号，如果现在餐馆还有很多空位，服务员会让你直接进入，如果没有了，你需要等候，直到叫到你的号为止。

此时，服务员就是信号量，空位个数就是信号量的值，你和其他食客相当于线程。

信号量本质上是一个记录可用资源数量的整型计数器，在RT-Thread里是一个内核对象，线程可以获取或释放。

### 信号量工作机制

每个信号量对象都有一个信号量值和一个线程等待队列，信号量的值对应了信号量对象的实例数目、资源数目。

假设现在信号量值为5，那就说明有5个实例可以使用，线程可以申请；为0则申请使用的线程必须挂起，直到有实例释放。

![](https://github.com/user-attachments/assets/c7ab7781-1a48-41df-a552-a1797b9ee80d)

### 信号量控制块

信号量控制块`rt_semaphore`是操作系统用于管理信号量的一个数据结构: 

```C
struct rt_semaphore
{
   struct rt_ipc_object parent;  /* 继承自 ipc_object 类 */
   rt_uint16_t value;            /* 信号量的值, max value = 65535 */
};
/* rt_sem_t 是指向 semaphore 结构体的指针类型 */
typedef struct rt_semaphore* rt_sem_t;
```

### 信号量的管理方式

如图是几大管理方式：

![](https://github.com/user-attachments/assets/47ee85fe-d885-4d42-9494-da9201cb9e0d)

#### 创建和删除信号量

创建并初始化一个信号量: 
```C
/**
 * @brief   创建并初始化一个信号量。
 *
 * @param   name    信号量的名称，用于调试和对象查找。
 * @param   value   信号量的初始计数值，通常表示可用资源的数量。
 * @param   flag    信号量的等待队列排序方式，支持以下标志：
 *                  - RT_IPC_FLAG_FIFO: 先进先出队列，先等待的线程优先获得信号量。
 *                  - RT_IPC_FLAG_PRIO: 优先级队列，高优先级线程优先获得信号量。
 *
 * @return  成功时返回指向信号量控制块的指针（rt_sem_t 类型）；
 *          失败时返回 RT_NULL，通常由于系统内存不足或 flag 非法导致。
 *
 * @note    1. 该函数不能在中断服务例程（ISR）中调用。
 *          2. 创建的信号量对象在系统堆中动态分配内存，不再使用时需通过
 *             rt_sem_delete() 删除并释放内存。
 *          3. flag 参数必须使用上述两个有效标志之一，否则创建失败。
 *
 * @see     rt_sem_delete()
 */
 rt_sem_t rt_sem_create(const char *name,
                        rt_uint32_t value,
                        rt_uint8_t flag);
```

删除：
```C
rt_err_t rt_sem_delete(rt_sem_t sem);
```
#### 初始化和脱离信号量

初始化一个信号量（静态分配）：
```C
/**
 * @brief   初始化静态信号量对象
 *
 * @note    该函数用于初始化一个静态分配的信号量对象。信号量是一种常用的同步机制，
 *          可用于解决任务间或中断与服务任务间的同步问题。调用此函数前，信号量对象
 *          的内存必须已经分配（可以是全局变量或静态分配的变量）。
 *
 * @param   sem     - 信号量对象的指针，指向已分配但未初始化的信号量控制块
 * @param   name    - 信号量的名称，长度不能超过 RT_NAME_MAX 个字符
 * @param   value   - 信号量的初始值，通常表示可用资源的数量
 * @param   flag    - 信号量的标志，决定等待队列的排序方式，可取以下值：
 *                    - RT_IPC_FLAG_FIFO  (0x00) 先进先出队列
 *                    - RT_IPC_FLAG_PRIO  (0x01) 优先级等待队列
 *
 * @return  rt_err_t - 执行结果
 * @retval  RT_EOK          (0)   : 初始化成功
 * @retval  -RT_ERROR      (1)   : 初始化失败（如参数为空）
 * @retval  -RT_EFULL      (-5)  : 标志参数非法（非 FIFO 或 PRIO）
 *
 * @see     rt_sem_create()    // 动态创建信号量
 * @see     rt_sem_detach()    // 脱离静态信号量
 */
rt_err_t rt_sem_init(rt_sem_t       sem,
                     const char     *name,
                     rt_uint32_t    value,
                     rt_uint8_t     flag);
```
脱离一个信号量：

```C
rt_err_t rt_sem_detach(rt_sem_t sem);
```

#### 获取信号量

当信号量值大于零时，线程将获得信号量，并且相应的信号量值会减 1: 

```C
rt_err_t rt_sem_take (rt_sem_t sem, rt_int32_t time);
// 如果在参数 time 指定的时间内依然得不到信号量，线程将超时返回，返回值是 - RT_ETIMEOUT。
```


#### 无等待获取信号量

当用户不想在申请的信号量上挂起线程进行等待时，可以使用无等待方式获取信号量:

```C
rt_err_t rt_sem_trytake(rt_sem_t sem);
```

:::info
这个函数与 rt_sem_take(sem, RT_WAITING_NO) 的作用相同.
:::

#### 释放信号量

释放信号量可以唤醒挂起在该信号量上的线程。

```C
rt_err_t rt_sem_release(rt_sem_t sem);
```

例如当信号量的值等于零时，并且有线程等待这个信号量时，释放信号量将唤醒等待在该信号量线程队列中的第一个线程，由它获取信号量；否则将把信号量的值加 1。

### 如何使用信号量

#### 线程间同步

两个线程需要进行同步，信号量的值初始化为0，尝试获得信号量的线程将直接等待。有实例被释放，等待结束，唤醒该线程。

#### 锁

锁，单一的锁常应用于多个线程间对同一共享资源（即临界区）的访问。

信号量在作为锁来使用时，通常应将信号量资源实例初始化成 1，代表系统默认有一个资源可用，因为信号量的值始终在 1 和 0 之间变动，所以这类锁也叫做二值信号量。

线程需要访问共享资源时，它需要先获得这个资源锁。那么由于只有一份可用资源，其他试图访问它的线程将挂起。（其他线程在试图获取这个锁时，信号量值是0，这个锁已经被锁上）

![](https://github.com/user-attachments/assets/761a1129-c8e3-46d7-a77a-fdfae373db8e)

获得信号量的线程处理完毕，退出临界区时，它将会释放信号量并把锁解开，而挂起在锁上的第一个等待线程将被唤醒从而获得临界区的访问权。

#### 中断与线程的同步

信号量也能够方便地应用于中断与线程间的同步，例如一个中断触发，中断服务例程需要通知线程进行相应的数据处理。

这个时候可以设置信号量的初始值是 0，线程在试图持有这个信号量时，由于信号量的初始值是 0，线程直接在这个信号量上挂起直到信号量被释放。

当中断触发时，先进行与硬件相关的动作，例如从硬件的 I/O 口中读取相应的数据，并确认中断以清除中断源，而后释放一个信号量来唤醒相应的线程以做后续的数据处理。

FinSH 线程的处理方式:

![](https://github.com/user-attachments/assets/d0b4aa2e-fa0d-4809-9104-ebd6dbd7bfee)

信号量的值初始为0，FinSH线程会被挂起。当有数据进来，产生中断，进入中断服务例程。

进入中断服务例程之后，读取数据，然后把数据存到UART Buffer里面去。之后释放信号量，唤醒FinSH线程。

中断服务例程运行完毕后，若无更高优先级的就绪线程存在，shell线程将持有信号量并运行，获取Buffer中的数据。

:::warning
中断与线程间的互斥不能采用信号量（锁）的方式，而应采用开关中断的方式。
:::

#### 资源计数

资源计数适合于线程间工作处理速度不匹配的场合。

由于信号量本质上是一个记录可用资源数量的整型计数器，可以将其看作为一个递增/递减的计数器。

信号量的值就是积压的工作数量。它可以对前一个线程完成的工作进行计数，也可以连续处理多个事件。


## 互斥量

互斥量又叫相互排斥的信号量，是一种特殊的二值信号量。

互斥量和信号量不同的是：拥有互斥量的线程拥有互斥量的所有权，互斥量支持递归访问且能防止线程优先级翻转；并且互斥量只能由持有线程释放，而信号量则可以由任何线程释放。


:::tip

普通二值信号量就像一个公共厕所的插销：谁进去都可以把门插上，出来时谁都可以把插销拉开（即使是路过的人）。这会导致混乱。

互斥量则像一把高级门禁卡：你刷开房门，门禁系统就记录下这张卡是谁的。只有持卡人才能再次刷卡锁门或开门，其他人即使捡到卡，系统也不认。

是不是很像RUST的所有权机制？这就是为什么RUST天生更加安全。

这个“所有权”是互斥量的灵魂。
:::

### 互斥量工作机制

互斥量只有两种状态的区别，那就是开锁和关锁。

![](https://github.com/user-attachments/assets/fdb72301-cfd3-42f3-a3d5-42fe8a26c8d6)

当线程持有它时，它处于关锁状态，释放时，进入开锁状态，线程失去对它的所有权。

当一个线程持有互斥量时，其他线程将不能够对它进行开锁或持有它，持有该互斥量的线程也能够再次获得这个锁而不被挂起。

:::tip
在信号量中，因为已经不存在实例，线程递归持有会发生主动挂起（最终形成死锁）。
:::



</WordCount>