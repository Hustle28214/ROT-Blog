import WordCount from '../../../../src/components/WordCount/WordCount';

<WordCount>

## 应用编程与裸机编程、驱动编程有什么区别？

我们说的这三种编程分别是指：

- 应用编程：基于 Linux 操作系统的应用编程，在应用程序中通过调用系统调用 API 完成应用程序的功能和逻辑，应用程序运行于操作系统之上。
- 裸机编程：**没有**操作系统支持的编程环境称为裸机编程环境
- 驱动编程：基于内核驱动框架开发驱动程序，驱动开发工程师通过调用 Linux 内核提供的接口完成设备驱动的注册

裸机程序当中，硬件操作代码和用户逻辑代码没有分离，也没有操作系统支持，编译之后就直接跑在硬件上。这就是“裸跑”。

而如果添加驱动，我们可以添加驱动函数，比如说open、write、release方法，当应用程序调用open系统调用，就会执行open函数。

应用程序和驱动程序应当是分离的，它们的编译也应当是独立的。应用程序运行在操作系统之上，有操作系统支持，应用程序处于用户态，而驱动程序处于内核态。

## 库函数

我们移植项目经常会遇见.so文件，这个.so文件就是库函数，库函数就是应用层使用的函数库，以动态.so库文件的形式提供，存放在lib之下。

- 库函数是属于应用层，而系统调用是内核提供给应用层的编程接口，属于**系统内核的一部分**；
- 库函数运行在用户空间，调用系统调用会由用户空间陷入到内核空间。
- 库函数通常是有缓存的，而系统调用是无缓存的，所以在性能、效率上，库函数通常要优于系统调用。
- 可移植性：库函数相比于系统调用具有更好的可移植性。虽然在不同的操作系统，内核向应用层提供的系统调用往往不同，但C语言库函数在不同操作系统中往往都是一样的，所以说可移植性是相对来说更好的。


### glibc源码获取

```bash
git clone https://sourceware.org/git/glibc.git
cd glibc
git checkout master
```
或者：

```bash
git clone https://sourceware.org/git/glibc.git
cd glibc
git checkout release/2.33/master
```
或者通过[ftn](https://ftp.gnu.org/gnu/glibc)下载。

Linux的glibc版本可以通过libc文件内容来确定。lib目录下方可能会存放一个libc.so.6文件，但是也可能还存在于其下方一个linux-gnu的目录中，需要find去找。

libc文件中，其stable release version x.xx就指的是glibc的版本号。

### main函数

许多开发中，main函数都是作为入口函数存在的。Linux开发中也是如此。

main函数的形参一般会有两种写法，如果执行应用程序无法传参，则可以写成如下形式：

```c
int main(void){
    /* code here，不传参 */
}
```

传参写法：
```c
int main(int argc,char **argv){
    /* code here */
}
```

或者这样传递参数

```bash
./exec 11
```

此时传入了两个参数。

第一个参数就是"./exec"，第二个参数就是"11"。

而且是argv[0]和argv[1]。因为argc 形参表示传入参数的个数，所以argc是2。

一个实际项目下需要管理成百上千的.c源文件。要保证他们之间正常的互相工作不是一件容易的事，所幸我们可以使用cmake来进行管理和编译，而不需要耗费大量的时间编写Makefile。

## 文件IO

### 简单的示例

```c
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
int main(void){
    char buf[1024];
    int fd1 = open("test.txt",O_RDONLY); /*只读方式*/
    int fd2 = open("test.txt",O_WRONLY);
    if (-1 == fd1)
        return fd1;
    if (-1 == fd2){
        ret = fd2;
        goto out1;
    }
    /* 读取源文件1KB数据到buf中去 */
    ret = read(fd1,buf,sizeof(buf));
    if (-1 == ret){
        goto out2;
    }

    /* 将buf中的数据写入到目标文件中去 */
    ret = write(fd2,buf,sizeof(buf));
    if (-1 == ret){
        goto out2;
    }

    ret =0;

out2:
    /*关闭文件*/
    close(fd2);

out1:
    /*关闭源文件*/
    close(fd1);
    return ret;
}
```

### 文件描述符

调用 open 函数会有一个非负整数的返回值，它就是文件描述符。

如果超过进程可打开的最大文件数限制，内核将会发送警告信号给对应的进程，然后结束进程；

通过 ``ulimit``命令来查看进程可打开的最大文件数，用法如下所示：

```bash
ulimit -n
```

该最大值默认情况下是 1024，也就是一个进程最多可以打开1024个文件。它可以通过``ulimit -n xxx``来修改这个值。

文件描述符是一种有限资源，从0开始分配。所以由此可知，文件描述符数字最大值为 1023（0~1023）。

每个被打开的文件在同一进程中都有一个喂一次的文件描述符，不可重复。

关闭文件后，文件描述符将被释放。

实际上，我们调用open函数打开文件后，文件描述符都是从3开始的，这是因为0、1、2是标准输入、输出、错误。这是已经默认分配好的。

标准输入一般是对应键盘，标准输出一般指的是LCD显示器。打开LCD设备时，所得到的文件描述符就是1，标准错误一般也是LCD显示器。


### open打开文件







## Reference

[1]. 正点原子官方.正点原子【第四期】手把手教你学 Linux之驱动开发篇 \[M/OL\](2019-12-04)[2025-01-10]. https://www.bilibili.com/video/BV1fJ411i7PB/?p=3&share_source=copy_web&vd_source=8b2bc57e71349607b55c9fde6b078ebd

</WordCount>