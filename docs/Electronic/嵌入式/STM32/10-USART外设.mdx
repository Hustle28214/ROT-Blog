
import WordCount from '../../../../src/components/WordCount/WordCount.jsx';
import Mermaid from '@theme/Mermaid';

<WordCount>

## 1. USART外设工作流程

![Image](https://github.com/user-attachments/assets/023756ae-cdf8-4f25-b225-92c752370e96)

发送数据寄存器（TDR）和接收数据寄存器（RDR）是USART外设的两个寄存器，用于存储发送和接收的数据。会视为一个寄存器，实际是两个寄存器。TDR只写，RDR只读。写操作时，数据写入TDR，读操作时，从RDR中读取数据。

两个移位寄存器，一个用于发送一个用于接收。它的作用是把一个字节的数据一位一位地移出去。

在某时刻，若给TDR写入了0x55这个数据，在寄存器里就是二进制存储。此时会检查：当前移位寄存器有没有数据正在移位，如果没有，二进制数据就会立刻全部移动到发送移位寄存器，准备发送。当数据从TDR移动到移位寄存器时，会置一个标志位，叫TXE(TX Empty)，发送寄存器空，检查该标志位，如果置1了，就可以在TDR写入下一个数据了。此时数据其实还没有发送出去，只要数据从TDR转移到发送移位寄存器了，TXE就会置1，就可以写入新的数据，然后发送移位寄存器就会在发生器的控制的驱动下，向右移位，然后一位一位地把数据传输到TX引脚；这里是向右移位，所以正好和串口协议规定的低位先行是一致的。当数据移位完成后，新的数据就会再次自动地从TDR转移到发送移位寄存器里来，如果当前移位还没有完成，TDR的数据就会进行等待，一旦完成，就会立刻转移过来。有了TDR和移位寄存器的双重缓存，可以保证连续发送数据的时候，数据帧之间不会有空闲，提高效率。

移位完成后，数据就会转移到数据寄存器RDR里。然后可以直接移位接收下一帧数据了。

转移过程中，也会置一个标志位，叫RXNE(RX Not Empty)，接收寄存器非空，检查该标志位，如果置1了，就可以从RDR读取数据了。此时数据其实还没有接收到，只要数据从移位寄存器转移到RDR了，RXNE就会置1，就可以读取新的数据了.


## 2. 发送器控制

发送器就是用来控制发送移位寄存器的工作。

硬件数据流控（流控，硬件流控制）主要解决发送设备频率太高，接收设备来不及处理，造成数据丢失、覆盖的问题。流控有2个引脚，一个是nRTS，一个nCTS。nRTS(Request to Send)是请求发送，是输出脚。nCTS(Clear to Send)是清除发送，是输入脚。"n"意思是低电平有效。

找到另一个支持流控的串口，其TX接收到RX，RTS输出一个能不能接收的反馈信号，接到对方的CTS，当我能接收的时候，RTS就置低电平，请求对方发送，对方的CTS接收到之后，就可以一直发。当处理不过来时，比如接收数据寄存器一直没读，又有新数据过来了，就代表没有及时处理；反过来，TX给对方发送数据时，CTS就要接到对方的RTS，用于判断对方能不能接收。TX和CTS是一对的，RX和RTS是一对的。CTS和RTS也要交叉连接。

SCLK控制电路用于产生同步的时钟信号，是配合发送移位寄存器输出的，发送寄存器每移位一次，同步时钟电平就跳变一个周期，时钟告诉对方，移出了一位数据，是否需要时钟信号来指导接收。时钟只支持输出，不支持输入。它可以兼容协议，自适应波特率（测量时钟周期，计算得出波特率）。

唤醒单元的作用是实现串口挂载多设备，串口一般是点对点的通信，多设备可以在一条总线上挂载多设备。当发送唤醒单元以指定地址时，就唤醒该设备进行工作。当没有收到指定地址时，设备保持沉默。

USART中断输出控制，中断申请位就是状态寄存器的各种标志位，状态寄存器有两个标志位比较重要，一个是TXE发送寄存器空，另一个是RXNE接收寄存器非空。是判断发送/接收状态的必要标志位。

波特率发生器其实就是分频器，APB时钟进行分配，得到发送和接收移位的时钟。时钟输入是fPCLKx(x = 1 or 2)，USART1挂载在APB2，所以就是PCLK2的时钟，一般是72M，其他的USART都挂载在APB1，所以是PCLK1的时钟，一般是36M。之后时钟进行分频，除一个USARTDIV的分频系数，USARTDIV分为了整数和小数部分（波特率用72M除一个整数，可能除不尽有误差），支持小数点后4位。分频后再除16，得到发送器时钟和接收器时钟，通向控制部分。如果TE(TX Enable)为1，就是发送器使能，发送部分的波特率就有效。如果RE(RX Enable)wei1，就是接收器使能，接收部分的波特率就有效。

![Image](https://github.com/user-attachments/assets/ca2120e8-36bd-4603-9359-e9d6f29a33ce)


## 3. 波特率发生器

发送器和接收器的波特率由波特率寄存器BRR里的DIV确定。

计算公式：波特率 $ = f_{PCLK2/1} / (16 * DIV)$

![Image](https://github.com/user-attachments/assets/9796ab2a-b089-4524-b6db-e85463a74946)

波特率发生器就是分频器。发生器和接收器的波特率由波特率寄存器BRR里面的DIV（分频系数）确定。

:::tip
为什么除以16？

因为内部还有一个16倍波特率的采样时钟。输入时钟/DIV等于16倍的波特率。
:::

在标准库的帮助下，需要多少波特率直接写就可以了。




</WordCount>
