
import WordCount from '../../../../src/components/WordCount/WordCount.jsx';
import Mermaid from '@theme/Mermaid';

<WordCount>

## 1. PWR电源控制

PWR（Power Control）电源控制。PWR负责管理STM32内部的电源供电部分，可以实现可编程电压监测器和低功耗模式的功能

可编程电压监测器（PVD）可以监控VDD电源电压，当VDD下降到PVD阀值以下或上升到PVD阀值之上时，PVD会触发中断，用于执行紧急关闭任务

低功耗模式包括睡眠模式（Sleep）、停机模式（Stop）和待机模式（Standby），可在系统空闲时，降低STM32的功耗，延长设备使用时间

![Image](https://github.com/user-attachments/assets/cc1fd9fd-423f-469b-81ac-ddbc64fd671b)

芯片在3种低功耗模式下，是没法直接再下载程序的。下载方式是：第一步，我们按住复位键不放。第二步点，下载按钮。第三步，及时松开复位键，这样就能下载成功了。

待机模式加实时时钟，是在实时时钟的基础上加入了待机模式。使用的是LSE外部低速时钟，如果没有RTC竞争或者RTC竞争不起劲，也可以使用LSI内部低速时钟。LSI在待机模式下可以继续工作。



## 2. 上电复位和掉电复位

当VDD或者VDDA电压过低时，内部电路直接产生复位，让STM32复位不要乱操作，复位和不复位的界限之间设置了一个40毫伏的迟滞电压。

![Image](https://github.com/user-attachments/assets/ceec9148-f524-45fd-9de5-497ca8492a15)

:::info
设置两个阈值的作用，就是防止电压在某个阈值附近波动时，造成输出也来回抖动。
:::


## 3. 可编程电压监测器

![Image](https://github.com/user-attachments/assets/3e75d1bf-5a97-4f96-b711-c4a8c4877d5a)

PVD监测的范围:2.2V-2.9V。

通过PVD设置一个警告线之后，再降低到1.9V，就是复位电路的监测范围。PVD触发之后，芯片还是能正常工作的，只不过是电源电压过低。

PVD输出是正逻辑，电压过低时为1，电压正常时为0，这个信号可以去申请中断，在上升沿或者下降沿时触发中断，一致提醒程序进行适当的处理。另外这个PVD的中断申请是通过外部中断实现的。

使用PVD的话，记得要配置外部中断。


## 4. 低功耗模式 

![Image](https://github.com/user-attachments/assets/375d3ec7-233c-4fdd-9e0c-8528c6a3ebde)

睡眠模式是一般省电，停止模式是非常省电，待机模式是极为省电。三个低功耗模式的唤醒难度从上到下依次增高。

低功耗模式通过在系统空闲时降低或关闭部分硬件设备，例如将CPU断电或关闭，同时保留必要的唤醒电路以确保在有任务到来时能快速恢复工作。这样既能节省电能，又能保证设备功能的及时响应。

低功耗模式对于使用电池供电且需要长时间待机的设备至关重要，通过进入低功耗模式，在空闲时降低芯片功耗，从而延长电池寿命。

在低功耗模式下，为了进一步降低功耗，需要关闭那些在空闲状态下不需要运行的硬件设备，比如CPU、AD转换器等关键组件。同时，必须保留必要的唤醒电路，如串口接收数据中断唤醒、外部中断唤醒和RTC闹钟唤醒等，以便在需要时能迅速恢复工作。

低功耗模式设计的是只有外部中断，可以唤醒。

其他这些设备也想唤醒停止模式的话，都可以通过借道外部中断来实现。

TRST temple复位，持续时间典型值是2.5毫秒.

### 4.1 停止模式



### 4.2 待机模式

待机模式下，内部大部分电路电源被断开，数据丢失，程序需从头开始运行。

待机模式下，整个1.8V供电区域断电，仅备份电路和待机电路维持供电。唤醒条件是通过WKUP引起的上升沿、RTC闹钟事件的上升沿，触发IWDG复位退出待机模式。

在待机模式下，所有的IO引脚变为**高阻态**。对于输出来说，既不输出高电平，也不输出低电平，呈现高阻态，对于输入来说，不上拉，也不下拉，呈现浮空输入状态。

flash运行正常运行模式下，供电电流条件是外部时钟使能所有外设和关闭所有外设，然后各个主屏下的电流信号在右边可以看到耗电电流区间是几到几十，单位是毫安，最高是50毫安左右。最低是7毫安左右上下，对比使能所有外设比关闭所有外设更耗电。

不需要的外设，我们可以把它的时钟关掉。

对于频率来说，**降低主频**对于省电也是很划算的。降低主频后，耗电电流下降也很明显。

## 5. 模式选择

![Image](https://github.com/user-attachments/assets/85663419-2606-4c2d-931f-92dd1dbc431b)


## 6. 睡眠模式

睡眠模式下的供应电流，它的耗电也是毫安级别的，从几毫安到几十毫安不等。比正常模式下低一些。

执行完WFI/WFE指令后，STM32进入睡眠模式，程序暂停运行，唤醒后程序从暂停的地方继续运行

SLEEPONEXIT位决定STM32执行完WFI或WFE后，是立刻进入睡眠，还是等STM32从最低优先级的中断处理程序中退出时进入睡眠

在睡眠模式下，所有的I/O引脚都保持它们在运行模式时的状态

WFI指令进入睡眠模式，可被任意一个NVIC响应的中断唤醒

WFE指令进入睡眠模式，可被唤醒事件唤醒

## 7. 停止模式

1.8V供电区域的所有时钟都被停止，PLL、HSI和HSE被禁止，SRAM和寄存器内容被保留下来.CPU和外设的始终停止，但没有断电，当退出停止模式时，HSI会被选为主频。此外，当电压调节器处于低功耗模式时，从停止模式退出会有一段额外的启动延时。

在停止模式下，所有的I/O引脚都保持它们在运行模式时的状态.

当一个中断或唤醒事件导致退出停止模式时，HSI被选为系统时钟.停止模式只能通过EXCI唤醒中断模式唤醒WFI事件模式，唤醒WFE。

当电压调节器处于低功耗模式下，系统从停止模式退出时，会有一段额外的启动延时.

- WFI指令进入停止模式，可被任意一个EXTI中断唤醒

- WFE指令进入停止模式，可被任意一个EXTI事件唤醒

执行完WFI/WFE指令后，STM32进入停止模式，程序暂停运行，唤醒后程序从暂停的地方继续运行.


:::tip
总结就是：把运行的高速时钟都关了，CPU和外设都暂停工作，但是电压调节器并没有关，传感器和继电器数据可以维持原样。他的唤醒条件比较苛刻，只能通过外部中断唤醒。
:::

## 8. 待机模式

执行完WFI/WFE指令后，STM32进入待机模式，唤醒后程序从头开始运行。

PDDS+SLEEPDEEP置1，调用WFI或者WFE进入待机模式。

整个1.8V供电区域被断电，PLL、HSI和HSE也被断电，SRAM和寄存器内容丢失，只有备份的寄存器和待机电路维持供电。

在待机模式下，所有的I/O引脚变为高阻态（浮空输入）。

WKUP引脚（PA0）的上升沿、RTC闹钟事件的上升沿、NRST引脚上外部复位、IWDG复位退出待机模式。



</WordCount>